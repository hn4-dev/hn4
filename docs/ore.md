# HN4 Orbital Redundancy Encoding (ORE) - Architectural Specification (v2.2)

## 1. Executive Summary

Orbital Redundancy Encoding (ORE) is the native compression engine for the Hydra-Nexus 4 (HN4) storage subsystem. It is a high-throughput, structural deduplication algorithm engineered for kernel-mode constraints: zero recursion, deterministic memory footprint (O(1) state), and predictable worst-case latency.

ORE departs from classical LZ77 implementations by introducing "Ballistic Trajectories" and "Contextual Flux Hashing" to minimize signature footprint and maximize adaptability across diverse hardware topologies (HDD vs. SSD vs. NVM).

## 2. Terminology & Mapping

ORE employs domain-specific nomenclature to describe its operational mechanics. The table below maps these concepts to industry-standard compression terminology.

| Standard Terminology | ORE Terminology | Definition |
| :--- | :--- | :--- |
| **Input Stream** | **Flux** | The raw byte sequence entering the compression pipeline. |
| **Output Stream** | **Token Stream** | The encoded binary sequence generated by ORE. |
| **Hash Table** | **Gravity Well** | A direct-mapped lookup table tracking 4-byte sequences, distorted by context history to prevent collision attacks. |
| **Match / Reference** | **Orbital Echo** | A sequence of bytes that duplicates a previously encountered pattern. |
| **Offset** | **Orbit Delta** | The backward distance (in bytes) to the reference data. |
| **Sliding Window** | **Anchor Frame** | The maximum historical range (64KB) accessible for echoes. (Note: ORE allocates no window buffer; it references the input Flux directly). |
| **Literal** | **Carrier Span** | Incompressible raw bytes emitted directly to the stream. |
| **Run-Length (RLE)** | **Isotope** | **Constant Repetition.** A single byte repeats $N$ times (Slope = 0). |
| **Linear Delta** | **Gradient** | **Linear Progression.** A sequence where $v_i = v_{i-1} + Slope$. (Slope $\neq$ 0). |

## 3. Algorithmic Logic

### 3.1. Structure Detection (Heuristic Filter)
Before committing CPU cycles to full compression, ORE samples the input `Flux` to determine compressibility.
1.  **Block normalization:** If block size < 128 bytes, detection is skipped (Always Compress).
2.  **Sampling:** Eight samples are taken. `Stride = Length / 8`.
3.  **Heuristic:** If sampled bytes are identical (Isotopes) OR exhibit ASCII bitmask alignment, the block is accepted.
4.  **Trade-Off:** Blocks that lack ASCII structure (e.g., pure numeric binary) but contain strong gradients might be rejected by this filter to save CPU. This is an intentional design choice to prioritize throughput over maximal ratio on mixed workloads.

### 3.2. Gravity Well (Context-Aware Hashing)
The `Gravity Well` maintains position history. Unlike standard CRC-based hashes, ORE employs **Flux Distortion**:
1.  **Context Mixing:** The hash of the current 4-byte sequence is XORed with the *preceding* byte (shifted).
2.  **Fold:** The result is mixed using a multiplicative constant.

**Mathematical Logic:**
```c
// seq: Current 4-byte sequence
// context: The byte immediately preceding 'seq'
key = seq ^ (context << 24);
// Prime: 0x5bd1e995 (MurmurHash2 constant)
hash = (key * 0x5bd1e995) >> (32 - Table_Bits);
```
*Why:* This breaks standard "rolling hash" fingerprinting. The hash for "ABCD" depends entirely on whether it was preceded by 'X' or 'Y', effectively masking the signature of the data stream.

### 3.3. Orbital Encoding Loop
The engine scans the `Flux` using a priority state machine:
1.  **Isotope Check (O(1)):** Is the current 8-byte word a repeating pattern (e.g., `00000000`)? If yes, emit `Isotope`.
2.  **Gradient Check (O(N)):** Do the bytes follow a linear equation $f(x) = mx + c$?
    *   **SSD Mode:** Fast Scan (8 bytes).
    *   **HDD Mode:** Deep Scan (32 bytes with Fail-Fast Striding).
3.  **Carrier Accumulation:** If no pattern is found, accumulate byte into pending `Carrier Span`. (Note: Echo matching is currently reserved for future expansion; v1 relies on Isotope/Gradient/Literal).

## 4. Hardware & Topology Optimization

ORE is topology-aware. It interrogates the Hardware Abstraction Layer (HAL) to determine the physical characteristics of the underlying media and adjusts its execution strategy accordingly.

| Topology | Media Characteristics | Optimization Strategy |
| :--- | :--- | :--- |
| **HDD** (Rotational) | High Seek Latency, Low IOPS | **Deep Scan (Ratio Priority)**<br>Sacrifices CPU cycles to find weak gradients (32-byte window). Reducing physical sector usage is paramount to amortize seek costs. |
| **SSD** (NAND) | Moderate Latency, High IOPS | **Fast Scan (Throughput Priority)**<br>Uses shallow 8-byte windows. Balances compression ratio against CPU throughput to keep the NVMe pipe saturated. |
| **ZNS** (Zoned) | Sequential Write Only | **Fast Scan + Zone Alignment**<br>Ensures compressed payloads align with Zone Append boundaries. Avoids read-modify-write patterns. |
| **NVM** (Optane/RAM) | Ultra-Low Latency, CPU-Bound | **Stream Store (Memory Priority)**<br>Uses Non-Temporal (MOVNTDQ) instructions to bypass L3 cache during writes. Prevents cache pollution on high-bandwidth persistent memory. |

## 5. AI / Tensor Future Expansion (TODO)

The current ORE implementation focuses on scalar patterns (Isotopes and Linear Gradients). The roadmap includes expanding the "Tensor-Core" capabilities to support multi-dimensional data structures common in AI workloads.

**Planned Features:**
*   **Vector Quantization:** Detecting patterns in high-dimensional vectors (embeddings).
*   **Tensor Striding:** Compressing data based on N-dimensional locality (e.g., 3D textures or weights).
*   **GPU Direct Path:** Offloading decompression directly to accelerator memory via PCIe P2P.

*Status: Reserved Opcodes allocated. Implementation deferred to v2.*

## 6. Wire Format Specification

The ORE bitstream is a sequence of **Tokens**. There is no file header; the stream is self-describing.

### 6.1. Token Header (1 Byte)

| Bit 7-6 (Tag) | Bits 5-0 (Length) | Description |
| :---: | :---: | :--- |
| `00` | `Len` | **Literal** (Carrier Span). Followed by `Len` raw bytes. |
| `01` | `Len` | **Isotope** (RLE). Followed by 1 byte Payload. |
| `10` | `Len` | **Gradient** (Linear). Followed by 1 byte Start, 1 byte Slope. |
| `11` | `Len` | **Reserved**. (Decoder Panic). |

**Note:** The Length field stores `Count` directly. However, Isotope/Gradient tokens have an implicit bias of `+4` (MIN_SPAN) applied during decoding.

### 6.2. Variable Length Encoding (VarInt)
If `Len` in the header equals `63` (`HN4_LEN_MASK`), the length continues in subsequent bytes.
*   **Extension Byte (255):** Adds 255 to the length. This byte counts towards the 32-byte header limit. Continue reading.
*   **Remainder Byte (< 255):** Adds value to length. This byte terminates the sequence and does **not** count towards the header extension limit. Stop reading.

**Mathematical Limit:**
$$ MaxLength = 63 (Header) + (32 \times 255) (Extensions) = 8223 $$

*Constraint:* A remainder byte of 255 is illegal as it would imply a 33rd extension byte, violating the fixed header size limit.

### 6.3. Payload Structures

*   **Literal:** Raw bytes are copied directly.
    *   `[Tag:0|Len] [Data_0] ... [Data_N]`
*   **Isotope:** A single byte repeats `Len + 4` times.
    *   `[Tag:1|Len] [Value]`
*   **Gradient:** A linear sequence $v_i = Start + (i \times Slope)$.
    *   `[Tag:2|Len] [Start] [Slope]`

## 7. Comparison: ORE vs. LZ4 vs. Snappy

| Metric | HN4 ORE | LZ4 | Snappy |
| :--- | :--- | :--- | :--- |
| **Algorithm** | Hybrid (RLE + Gradient + Literal) | LZ77 (Dictionary) | LZ77 (Dictionary) |
| **Gradient Support** | **Yes (Native)** | No | No |
| **Structure Detect** | **Yes (Pre-filter)** | No | No |
| **State Memory** | **O(1) (Stateless)** | 16KB+ | 4KB+ |
| **Logical Window** | **64KB (Anchor Frame)** | 64 KB | 32 KB |
| **Smallest Match** | 4 Bytes | 4 Bytes | 3 Bytes |
| **NVM Optimization** | **Native (Stream Store)** | No | No |
| **Worst-Case Expansion** | ~0.79% | ~0.40% | ~12.5% |
| **Safety** | Kernel-Hardened (No recursion) | User/Kernel | User/Kernel |

**Note on State:** ORE is stateless in terms of persistent allocation (it requires no external hash table memory between calls), but logically operates within a 64KB "Anchor Frame" (sliding window) relative to the current pointer position for back-references (planned v2 Echo support). v1 relies purely on local context (Isotopes/Gradients).

## 8. Safety Invariants

1.  **Strict Grammar:** The VarInt decoder explicitly rejects streams requiring >32 extension bytes or invalid remainders (255).
2.  **Trajectory Validation:** Gradient decoding validates endpoints using 64-bit math to prevent intermediate integer overflows during reconstruction.
3.  **Bounds Checking:** Every read/write operation is checked against the remaining buffer capacity *before* execution.
4.  **Zero Gravity:** Degenerate slopes (0) or invalid slopes (-128) in Gradients are treated as data corruption (`HN4_ERR_DATA_ROT`).
